{"version":3,"sources":["../../server/templates/index.js"],"names":["loadFor","template","path","Promise","res","matchedPath","_","get","result","set","parse","variables","paths","injectedTemplate","queue","map","loadedTemplates","all","mergedTemplate","reduceRight","flattened","other","merge","clone","resolve","setup","templates"],"mappings":";;;;;;;;;AAEA;;;;AAEA;;AACA;;;;;;AAIA,MAAMA;AAAA,+BAAU,WAAOC,QAAP,EAAiBC,IAAjB;AAAA,WACd,IAAIC,OAAJ;AAAA,oCAAY,WAAOC,GAAP,EAAe;AACzB,cAAMC,cAAcC,iBAAEC,GAAF,CAAMN,QAAN,EAAgBC,IAAhB,CAApB;;AAEA,YAAIG,eAAe,IAAf,IAAuB,OAAOA,WAAP,KAAuB,QAAlD,EAA4D;AAC1D,iBAAOD,iBACFH,QADE,EAAP;AAGD;;AAED,cAAMO,SAAS,MAAM,gBAAKH,WAAL,CAArB;;AAEA,eAAOD,IAAIE,iBAAEG,GAAF,cAEJR,QAFI,GAITC,IAJS,EAKTM,MALS,CAAJ,CAAP;AAOD,OAlBD;;AAAA;AAAA;AAAA;AAAA,SADc;AAAA,GAAV;;AAAA;AAAA;AAAA;AAAA,IAAN;;AA2BA,MAAME,QAAkB,CAACT,QAAD,EAAWU,SAAX,EAAsBC,KAAtB,KACtB,IAAIT,OAAJ;AAAA,gCAAY,WAAOC,GAAP,EAAe;AACzB,UAAMS,mBAAmB,gCAAaZ,QAAb,eACpBU,SADoB,EAEpBV,SAASU,SAFW,EAAzB;;AAKA,UAAMG,QAAQF,MAAMG,GAAN,CAAU;AAAA,aAAQf,QAAQa,gBAAR,EAA0BX,IAA1B,CAAR;AAAA,KAAV,CAAd;;AAEA,UAAMc,kBAAkB,MAAMb,QAAQc,GAAR,CAAYH,KAAZ,CAA9B;;AAEA,UAAMI,iBAAiBZ,iBAAEa,WAAF,CACrBH,eADqB,EAErB,UAACI,SAAD,EAAYC,KAAZ;AAAA,aAAsBf,iBAAEgB,KAAF,CAAQhB,iBAAEiB,KAAF,CAAQH,SAAR,CAAR,EAA4BC,KAA5B,CAAtB;AAAA,KAFqB,EAGrB,EAHqB,CAAvB;;AAMA,WAAOjB,IAAI,gCAAac,cAAb,eACNP,SADM,EAENO,eAAeP,SAFT,EAAJ,CAAP;AAID,GApBD;;AAAA;AAAA;AAAA;AAAA,KADF;;AAyBO,MAAMa;AAAA,gCAAsB,WAAOC,KAAP,EAAiB;AAClD,UAAMb,QAAQ,CAAC,CAAC,UAAD,EAAa,MAAb,CAAD,EAAuB,CAAC,UAAD,EAAa,MAAb,CAAvB,EAA6C,CAAC,UAAD,EAAa,SAAb,CAA7C,CAAd;;AAEA,UAAME,QAAQW,MAAMC,SAAN,CAAgBX,GAAhB,CAAoB;AAAA,aAAYL,MAAMT,QAAN,EAAgBwB,MAAMd,SAAtB,EAAiCC,KAAjC,CAAZ;AAAA,KAApB,CAAd;;AAEA,UAAMc,YAAY,MAAMvB,QAAQc,GAAR,CAAYH,KAAZ,CAAxB;;AAEA,wBACKW,KADL;AAEEC;AAFF;AAID,GAXY;;AAAA;AAAA;AAAA;AAAA,IAAN","file":"index.js","sourcesContent":["/* @flow */\n\nimport _ from 'lodash';\n\nimport { InjectValues } from './injectValues';\nimport { load } from './load';\n\nimport type { Setup, Template, Variables } from '../types';\n\nconst loadFor = async (template, path) =>\n  new Promise(async (res) => {\n    const matchedPath = _.get(template, path);\n\n    if (matchedPath == null || typeof matchedPath !== 'string') {\n      return res({\n        ...template,\n      });\n    }\n\n    const result = await load(matchedPath);\n\n    return res(_.set(\n      {\n        ...template,\n      },\n      path,\n      result,\n    ));\n  });\n\ntype ParseDef = (\n  template: Template,\n  variables: Variables,\n  paths: Array<Array<string>>,\n) => Promise<Template>;\n\nconst parse: ParseDef = (template, variables, paths) =>\n  new Promise(async (res) => {\n    const injectedTemplate = InjectValues(template, {\n      ...variables,\n      ...template.variables,\n    });\n\n    const queue = paths.map(path => loadFor(injectedTemplate, path));\n\n    const loadedTemplates = await Promise.all(queue);\n\n    const mergedTemplate = _.reduceRight(\n      loadedTemplates,\n      (flattened, other) => _.merge(_.clone(flattened), other),\n      {},\n    );\n\n    return res(InjectValues(mergedTemplate, {\n      ...variables,\n      ...mergedTemplate.variables,\n    }));\n  });\n\ntype ResolveDef = (setup: Setup) => Promise<Setup>;\n\nexport const resolve: ResolveDef = async (setup) => {\n  const paths = [['response', 'body'], ['validate', 'body'], ['validate', 'headers']];\n\n  const queue = setup.templates.map(template => parse(template, setup.variables, paths));\n\n  const templates = await Promise.all(queue);\n\n  return {\n    ...setup,\n    templates,\n  };\n};\n"]}