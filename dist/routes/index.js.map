{"version":3,"sources":["../../server/routes/index.js"],"names":["logger","readFileAsync","readFile","loadReponse","path","process","cwd","then","str","JSON","parse","parseTemplate","template","variables","Promise","res","resolved","response","body","makeRoute","parsedTemplate","routeType","method","toLowerCase","type","route","status","query","findRouteForRequest","routes","req","find","_","isEqual","defineRoute","router","name","matchedRoute","send","arrangeRoutes","iteratee","forEach","groupBy","groupedRoutesByType","groupedRoutesByPath","create","setup","Router","queue","templates","map","all","routeMaker","arrangedRoutes","debug"],"mappings":"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","file":"index.js","sourcesContent":["/* @flow */\n\nimport { readFile } from \"fs\";\nimport { promisify } from \"util\";\nimport { join as joinPath } from \"path\";\nimport _ from \"lodash\";\n\nimport { Router } from \"express\";\n\nimport { resolveTemplate, log } from \"../utils\";\nimport type { Setup, Template, Variables } from \"../types\";\n\nconst logger = log(\"routes\");\n\nconst readFileAsync = promisify(readFile);\n\ntype LoadResponseDef = (path: string) => Promise<{}>;\n\nconst loadReponse: LoadResponseDef = path =>\n  readFileAsync(joinPath(process.cwd(), path), \"utf-8\").then(str =>\n    JSON.parse(str)\n  );\n\ntype ParseTemplateDef = (\n  template: Template,\n  variables: Variables\n) => Promise<Template>;\n\nconst parseTemplate: ParseTemplateDef = (template, variables) =>\n  new Promise(async res => {\n    const resolved = resolveTemplate(template, {\n      ...variables,\n      ...template.variables\n    });\n\n    if (typeof template.response.body === \"string\") {\n      const body = await loadReponse(resolved.response.body);\n\n      return res({\n        ...template,\n        response: {\n          ...template.response,\n          body\n        }\n      });\n    }\n\n    return res(template);\n  });\n\ntype MakeRouteDef = (\n  template: Template,\n  variables: Variables\n) => Promise<{\n  type: string,\n  path: string,\n  status: number,\n  query: {},\n  response: { [key: string]: string }\n}>;\n\nconst makeRoute: MakeRouteDef = (template, variables) =>\n  new Promise(async res => {\n    const parsedTemplate = await parseTemplate(template, variables);\n\n    const resolved = resolveTemplate(parsedTemplate, {\n      ...variables,\n      ...template.variables\n    });\n\n    const routeType = resolved.method.toLowerCase();\n\n    return res({\n      type: routeType,\n      path: resolved.route,\n      status: resolved.response.status,\n      query: resolved.query || {},\n      response: resolved.response.body\n    });\n  });\n\nconst findRouteForRequest = (routes, req) =>\n  routes.find(route => {\n    return _.isEqual(req.query, route.query);\n  });\n\nconst defineRoute = router => ({ type, name, routes }) =>\n  // $FlowFixMe\n  router[type](name, (req, res) => {\n    const matchedRoute = findRouteForRequest(routes, req);\n\n    res.status(matchedRoute.status).send(matchedRoute.response);\n  });\n\nconst arrangeRoutes = (routes, iteratee) =>\n  _.forEach(_.groupBy(routes, \"type\"), (groupedRoutesByType, type) => {\n    _.forEach(\n      _.groupBy(groupedRoutesByType, \"path\"),\n      (groupedRoutesByPath, name) => {\n        iteratee({\n          type,\n          name,\n          routes: groupedRoutesByPath\n        });\n      }\n    );\n  });\n\nexport const create = async (setup: Setup) => {\n  const router = new Router();\n\n  const queue = setup.templates.map(template =>\n    makeRoute(template, setup.variables)\n  );\n\n  const routes = await Promise.all(queue);\n\n  const routeMaker = defineRoute(router);\n\n  arrangeRoutes(routes, ({ type, name, routes: arrangedRoutes }) => {\n    logger.debug(\"created\", arrangedRoutes);\n\n    // $FlowFixMe\n    routeMaker({\n      type,\n      name,\n      routes: arrangedRoutes\n    });\n  });\n\n  return router;\n};\n"]}